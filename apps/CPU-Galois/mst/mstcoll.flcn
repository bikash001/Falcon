Graph hgraph;
Set hset[Point(hgraph)];

struct node{
	Point (hgraph) src;
	Point (hgraph) dst;
	int weight;
};

int glimit;
int bcnt;
struct workitem{
	Point (hgraph) src;
	Point (hgraph) dst;
	int weight;
	int cur;
};

Collection WL1[struct workitem],WL2[struct workitem],WL3[struct workitem],WL4[struct workitem];
Collection mst[struct node],*current[struct workitem],*next[struct workitem],*pending[struct workitem];
Collection *temp[struct workitem];
Collection temp11[struct workitem];
Collection coll1[ Point(hgraph)];

void findLightest(struct workitem req,Graph hgraph,Collection pred [struct workitem],Collection next[struct workitem],Collection pending[struct workitem],int useLimit,Set hset[Point(hgraph)]){
	struct workitem req1;
	req1=req;
	Point (hgraph) src=req1.src;
	int cur=req1.cur;
	foreach(t ( + cur) In  src.outnbrs){
		int weight=hgraph.getweight(src,t);
		if(useLimit && weight>glimit){
			struct workitem tt;
			tt.src=src;
			tt.dst=t;
			tt.weight=weight;
			tt.cur=cur;
			pending.add(tt);
			return;
		}
		Point (hgraph) rep=hset.find(src);
		Point (hgraph) dst;
		int old,ch;
		rep=hset.Findcompress(src);
		if(rep!=hset.Findcompress(t)){
			struct workitem tt;
			tt.src=src;
			tt.dst=t;
			tt.weight=weight;
			tt.cur=cur;
			next.add(tt);
			while(weight < (old=hgraph.points[rep].minedge)){
				MIN(rep.minedge,weight,ch);
			}
			return;
		}
		cur=cur+1;
	}
}

void findLightest1(struct workitem req,Graph hgraph,Collection pred [struct workitem],Set hset[Point(hgraph)]){
	struct workitem req1;
	req1=req;
	Point (hgraph) src=req1.src;
	Point (hgraph) rep=hset.Findcompress(src);
	int cur=req1.cur;
	int weight=req1.weight;
	if(rep<hgraph.npoints && hgraph.points[rep].minedge==weight){
		Point (hgraph) dst=req1.dst;
		rep=hset.Merge(src,dst);
		if(dst<hgraph.npoints && rep){
			hgraph.points[rep].minedge=1234567890;
			struct node tt;
			tt.src=src;
			tt.dst=dst;
			tt.weight=req1.weight;
			mst.add(tt);
		}
	}
}

void findLightest2(Point p,Graph hgraph,Collection pred [struct workitem],Collection next[struct workitem],Collection pending[struct workitem],int useLimit,Set hset[Point(hgraph)]){
	struct workitem req;
	req.src=p;
	req.cur=0;
	findLightest(req, hgraph,pred,next, pending, useLimit, hset);
}

int main(int argc,char *argv[]){
	if(argc!=4){
		printf("exec -t theads file");
		return 1;
	}
	hgraph.addPointProperty(minedge,int);
	int a;
	hgraph.read(argv[3]);
	for(int i=0;i<hgraph.npoints;i++)hgraph.sortEdges(i);
	glimit=2000;
	current=&WL1;
	next=&WL2;
	pending=&WL3;
	int bcnt=0;
	double rt1=rtclock();
	for(int i=0;i<hgraph.npoints;i++){
		hgraph.points[i].minedge=1234567890;
	}
	foreach(t In coll1)
		findLightest2(t,hgraph,*current,*next,*pending,bcnt,hset);

	bcnt=1;
	while(1){
		while(1){
			temp=current; 
			current=next; 
			next=temp;
			foreach(t In *current)findLightest1(t,hgraph,*current,hset);
			foreach(t In *current)findLightest(t,hgraph,*current,*next,*pending,bcnt,hset);
			*current.clear();
			if(*next.empty())break;
		}
		glimit*=2;
		if(*pending.empty())break;
		temp=next; 
		current=pending; 
		next=temp;
	}
	double rt2=rtclock();
	printf("TIME=%f \n",(rt2-rt1)*1000);
	return 0;
}